INTRODUCTION

Hello and welcome to the manual for code-immersion, a lightweight PLT scheme framework for code collaboration, designed for a Hampshire College class (by the name "Code Immersion") and implemented to run on top of DrScheme. If you'd like to just get started with code-immersion rapidly (and have a bit of knowledge), take a look at the quick-start guide; if you're new to the entire system, have a look at the comprehensive walkthrough; if you need specific information on some bit of the framework, look into the reference section.

TABLE OF CONTENTS

 I. Introduction
 II. Quick-start guide
  A. Prerequisites
  B. Get code-immersion
  C. Configure
   i. SERVER
   ii. DAEMON
   iii. SERVER-PORT
   iv. DAEMON-PORT
   v. NAME
   vi. FORMAT-STRING
   vii. DATASTORE-TYPE
  D. Start background processes
   i. server
   ii. daemon
  E. Use client functions
   i. send-code and send-message
   ii. display-code and display-message
   iii. evaluate-code
 III. Comprehensive Walkthrough
 IV. Reference
  A. Configuration options
   i. SERVER
   ii. DAEMON
   iii. SERVER-PORT
   iv. DAEMON-PORT
   v. NAME
   vi. FORMAT-STRING
   vii. DATASTORE-TYPE
  B. Function Reference
   i. Server
    a. Exported
     1. (server #:port [port SERVER-PORT])
    b. Internal
     1. (register-client port)
     2. (get-output-port-list)
     3. (dispatch name type message)
     4. (new-server #:port [port SERVER-PORT])
   ii. Daemon
    a. Exported
     1. (daemon #:server [server SERVER] #:server-port [server-port SERVER-PORT] #:self-port [self-port DAEMON-PORT] #:datastore-put [datastore-put (car DATASTORE)] #:datastore-get [datastore-get (cadr DATASTORE)])
     2. (register-with #:server [server SERVER] #:port [port SERVER-PORT] #:datastore-put [datastore-put (car DATASTORE)] #:datastore-get [datastore-get (cadr DATASTORE)])
   iii. Client
    a. Exported
     1. (send-to #:name [name NAME] #:place place #:port port #:type type message)
     2. (send-to-server #:name [name NAME] #:server [server SERVER] #:port [port SERVER-PORT] #:type type message)
     3. (send-to-daemon #:name [name NAME] #:daemon [daemon DAEMON] #:port [port DAEMON-PORT] #:type type message)
     4. (send-code #:name [name NAME] #:server [server SERVER] #:port [port SERVER-PORT] code)
     5. (send-message #:name [name NAME] #:server [server SERVER] #:port [port SERVER-PORT] message)
     6. (request-message #:number index #:from name #:daemon [daemon DAEMON] #:port [port DAEMON-PORT])
     7. (request-code #:number index #:from name #:daemon [daemon DAEMON] #:port [port DAEMON-PORT])
     8. (display-message #:number index #:from name #:daemon [daemon DAEMON] #:port [port DAEMON-PORT] #:format-string [format-string FORMAT-STRING])
     9. (display-code #:number index #:from name #:daemon [daemon DAEMON] #:port [port DAEMON-PORT] #:format-string [format-string FORMAT-STRING])
     10. (evaluate-code #:number index #:from name #:daemon [daemon DAEMON] #:port [port DAEMON-PORT])
   iv. Datastore
    a. Exported
     1. list-datastore
     2. hash-datastore
     3. DATASTORE
   v. Utilities
    a. Exported
     1. (verify-data data)
     2. (format-prettily message #:format-string [format-string FORMAT-STRING])
     3. (ignoring-errors code)
     4. (print-all-source)
     5. (define-listener-and-verifier port close? body)
    b. Internal
     1. (string-from-text-file text-file-port)

QUICK-START GUIDE
 A. Prerequisites

You should get DrScheme and an mzscheme environment set up first. See http://plt-scheme.org/ for more details on that.

 B. Get code-immersion

git clone git://github.com/ianmcorvidae/code-immersion.git

or 

http://github.com/ianmcorvidae/code-immersion/tree/master and hit the "Download" button. Put this somewhere that you'll remember, you'll be using it a bit.

 C. Configure

Wherever you put code-immersion, unzip/untar it and copy config-example.ss to config.ss in the same directory. Then, edit config.ss and change the values below to what they should be in the (define ...) form (that is: if you want to change the value of SERVER from the default of "localhost" to "192.168.0.13", change it to (define SERVER "192.168.0.13"))
  i. SERVER
The IP address or hostname of the server that the client and the daemon should be connecting to. Make it a string: put quotes around it.
  ii. DAEMON
The IP address or hostname of the daemon that the client should be connecting to. Make it a string too.
  iii. SERVER-PORT
The TCP port number that the above host uses. Don't make this one a string.
  iv. DAEMON-PORT
The TCP port number for the above host (except this time, the daemon one, not the server one). Not a string either.
  v. NAME
This is the name you want to go by for the sake of the server and client (and thereby, in anyone else's daemon. String.
  vi. FORMAT-STRING
Probably not important to you, but this changes how things are displayed when you use the display-code or display-message functions. See the reference section for more.
  vii. DATASTORE-TYPE
Probably not important (or at least, not needing change). This changes what datastore your daemon uses for things. Right now, only one works anyway.

 D. Start background processes

  i. server
Load up server.ss and run (server) -- or, if you're really frisky, start it up with a custom port: (server #:port <number>) where <number> is your self-chosen port number (note: SERVER-PORT above will change this, but doing it by way of the keyword overrides that.
  ii. daemon
Load up daemon.ss and run (daemon) -- if you were really frisky above, add the keyword #:server-port <number> to match the above value, or change the daemon's port number with #:self-port <number>. Use #:server to change what hostname/IP the server's at.
 E. Use client functions
  i. send-code and send-message
These send code and send messages. If you changed the port for the server with keyword options (not SERVER-PORT) then you'll need to deal with that here too. See Reference.
  ii. display-code and display-message
These display prettily (well, sort of) code or messages from others. Format is (display-(code|message) #:from <name> #:number <number>) where <name> is the name of the person whose code or message you want to see, and <number> is the index (starts with 0 from most-recently-received) of the code or message you want to see.
  iii. evaluate-code
Same format as the display function, except this one runs the code. Use at your own risk; if someone sends you code that makes your computer explode or somesuch, use of this function is not recommended. Also, get new programming buddies.

COMPREHENSIVE WALKTHROUGH 

(note: I will make some comments at the end for users of Ubuntu and other distributions of Linux. Unfortunately, for the sake of this walkthrough, I must assume that most people are using either Windows or Mac.)

First, get yourself a copy of DrScheme and PLT Scheme from http://download.plt-scheme.org/drscheme/ and install it.

Next, get code-immersion (if you haven't already). Use the "Download" button on http://github.com/ianmcorvidae/code-immersion/tree/master. Most likely you will want the .zip version. Then, find a directory where you would like to do your programming (I recommend making a separate directory for this) and unpack code-immersion into that directory.

Go into the directory where code-immersion is. Copy the file called 'config-example.ss' to 'config.ss' and then edit config.ss in a text editor (or open it in DrScheme, if you so desire). You need to change a couple values:
1.) change "Unconfigured Name" in the line that looks like (define NAME "Unconfigured Name") to your name, in quotes (e.g. I would change that line to (define NAME "Ian McEwen") ).
2.) If you have been told an address for the server (e.g. by your teacher), you should put this in place of 'localhost' in the line reading (define SERVER "localhost"). For example, if you've been told the server is at 192.168.0.12, change that line to read (define SERVER "192.168.0.12"). If you are testing out code-immersion on your own system, do not change this line.

Now, to test if the whole system is working properly. First, make another directory next to the code-immersion folder; name it what you want. (for example, if code-immersion is in the folder "C:/programming/code-immersion/" make another folder inside the "C:/programming/" folder). Open up DrScheme. It will probably ask you to choose a language. Choose the option at the very top, labeled "Module". The document it creates should have only one line, reading '#lang scheme'. 

First, open two new tabs (using File -> New Tab). In two of these tabs, open up daemon.ss and server.ss from code-immersion using File -> Open. 
Then, go to the tab where you opened up server.ss. Hit the "Run" button near the top right.
In the smaller box that opens near the bottom of the window (called the REPL), type (server) and hit Enter.

This window should then look like:
Welcome to DrScheme, version 4.2.0.2-svn2jun2009 [3m].
Language: Module; memory limit: 128 megabytes.
> (server)

There should be a blinking cursor on the next line. This is now set. Go to the tab where you opened up daemon.ss, and hit the "Run" button as you did on the server tab. This time, type (daemon) in the REPL to start the daemon. You should see this on the screen:
Welcome to DrScheme, version 4.2.0.2-svn2jun2009 [3m].
Language: Module; memory limit: 128 megabytes.
> (daemon)
text from server: Registered.

The daemon is now running. Now go to the third tab, the one where you haven't yet done anything. Enter the following line below the '#lang scheme':
(require "../code-immersion/client.ss")

Save this file with the extension .ss in the folder you created just before you opened up DrScheme (for example, if code-immersion is in "C:/programming/code-immersion/ and the folder you created was "C:/programming/test/" then the file should be "C:/programming/test/something.ss"). Now, hit "Run". In the REPL that should appear, type (send-message "test") and hit Enter. This should complete and give you another line of REPL starting with a >; your REPL window should look like this:
Welcome to DrScheme, version 4.2.0.2-svn2jun2009 [3m].
Language: Module; memory limit: 128 megabytes.
> (send-message "test")
("server" "text" "Dispatched.")
>

Now, go back to the daemon.ss window. You should now see a line like this:
text from Ian McEwen: test

One last test -- go back to the new file you created and type:
(display-message #:number 0 #:from "Your Name")

Clearly, "Your Name" should not be that literally, but actually your name, in quotes. Hit Enter. You should see a line that looks like this:
text from Ian McEwen index 0: test

If all of this has gone off without a hitch, you should be up and ready to use code-immersion! If something seems to be amiss, go over this walkthrough again and make sure everything was done properly. If DrScheme or something else is giving you an error message, try to interpret it or use google to determine the cause of the problem. As a last resort, find someone to help you out.

After the brief section on Linux-specific notes, read on to learn the basics of using code-immersion.

FOR LINUX USERS:
DrScheme can be acquired from another system such as a package manager (typically, if you are running a distribution of Linux -- on Ubuntu install it with 'sudo aptitude install drscheme' or through Synaptic).

On Linux, a faster way to get code-immersion is to install the package 'git-core' with 'sudo aptitude install git-core' or through synaptic, and then (from the command line) running: 'git clone git://github.com/ianmcorvidae/code-immersion.git' in the directory ABOVE the one where you want code-immersion (the same folder you would extract the .zip or .tar.gz into).

BASIC USAGE

Any project you are working on, if you followed the above walkthrough, should be in a subfolder of the programming folder you have code-immersion in a subdirectory of. In order to use the features of code-immersion in any given file, you should have the (require "../code-immersion/server.ss") line at the top below the '#lang scheme' line. You should be using code-immersion in a classroom or other collaborative setting -- make sure that you change the server in config.ss (as described above) to the proper value as given to you by your instructor or other leader. Then, open up a new window and start the daemon as described above (open up daemon.ss, hit Run, run '(daemon)' in the REPL). Now you should be able to use the various functions of the client; I'll go over each below.

1.) (send-code code): Use this, with 'code' being quoted code, to send code to everyone connected to the same server as you. For example, to send the code (display 'test) to everyone, use (send-code '(display 'test)). Note that there is only a single quote before the (display 'test), and none after. This is correct.

2.) (send-message message): Use this, with 'message' being a string, to send a message to everyone. To send the message "test" to everyone, use (send-message "test).

3.) (display-code #:number index #:from name): Use this to print out but not run code others have sent to you. 'index' should be replaced with a number 0 or greater; for the most recent thing sent, use 0; for the next-most-recent, 1, and so forth. 'name' should be the name of the person who sent the code. So, if you want to see the last piece of code I sent to you, use (display-code #:number 0 #:from "Ian McEwen").

4.) (display-message #:number index #:from name): Use this to print out messages others have sent to you. 'index' and 'name' should be replaced as above -- so, to see the third-most-recent message I sent out, use (display-message #:number 2 #:from "Ian McEwen").

5.) (evaluate-code #:number index #:from name): Use this to run code others have sent to you. The parameters are the same as for display-code. So, to run the second-most-recent piece of code I've sent to you, use (evaluate-code #:number 1 #:from "Ian McEwen").

For more detailed (and more technical) information on code-immersion, read on into the REFERENCE section.

REFERENCE

  A. Configuration options
   i. SERVER
String. The hostname or IP address of the server to be used by the daemon and client. Default: "localhost"
   ii. DAEMON
String. The hostname or IP address of the daemon to be used by the client. Default: "localhost"
   iii. SERVER-PORT
Integer. The TCP port number for the server to listen on, and for the daemon and client to connect to. Default: 2000
   iv. DAEMON-PORT
Integer. The TCP port number for the daemon to listen on, and for the client to connect to. Default: 2005
   v. NAME
String. Some unique identifier for the individual user of the software; used by the client and seen by the daemon. Default: "Unconfigured Name"
   vi. FORMAT-STRING
String. Used by the function (format-prettily ...) to format the type, name, and message being printed. Used within the function call thus: (format format-string type name message)
   vii. DATASTORE-TYPE
String. Defines which datastore to use. Currently, valid values are "list-datastore" and "hash-datastore", but only hash-datastore actually works. Default: "hash-datastore".

  B. Function Reference
   i. Server
    a. Exported
     1. (server #:port [port SERVER-PORT])
Starts a listening server on TCP port 'port' or, when called without keyword arguments, on SERVER-PORT.
    b. Internal
     1. (register-client port)
Adds the output port 'port' to the internal list of ports to dispatch messages to.
     2. (get-output-port-list)
Returns the list of ports messages should be dispatched to.
     3. (dispatch name type message)
Dispatches a message to all relevant sources with given name, type, and message.
     4. (new-server #:port [port SERVER-PORT])
Unused. Creates a dummy server that simply prints (on the server side) whatever it gets as a message. Useful only for debugging purposes.
   ii. Daemon
    a. Exported
     1. (daemon #:server [server SERVER] #:server-port [server-port SERVER-PORT] #:self-port [self-port DAEMON-PORT] #:datastore-put [datastore-put (car DATASTORE)] #:datastore-get [datastore-get (cadr DATASTORE)])
Starts a listening daemon on port 'self-port' with datastore functions datastore-put and datastore-get; registers this daemon with server 'server' on port 'server-port'. Without keyword options, listens on DAEMON-PORT using (car DATASTORE) and (cadr DATASTORE) as datastore functions, and registers with SERVER on port SERVER-PORT.
     2. (register-with #:server [server SERVER] #:port [port SERVER-PORT] #:datastore-put [datastore-put (car DATASTORE)] #:datastore-get [datastore-get (cadr DATASTORE)])
Used by (daemon) to register with a server; four options server, port, datastore-put, and datastore-get are as in that function, except that 'port' is 'server-port' in that function.
   iii. Client
    a. Exported
     1. (send-to #:name [name NAME] #:place place #:port port #:type type message)
Generic send function to a server or daemon. Sends (name type message) to 'place' on port 'port'. 'name' defaults to NAME.
     2. (send-to-server #:name [name NAME] #:server [server SERVER] #:port [port SERVER-PORT] #:type type message)
Uses (send-to ...) to send to a server; same as that function except it changes 'place' to 'server' and defaults server to SERVER and port to SERVER-PORT.
     3. (send-to-daemon #:name [name NAME] #:daemon [daemon DAEMON] #:port [port DAEMON-PORT] #:type type message)
Uses (send-to ...) to send to a daemon; same as that function except it changes 'place' to 'daemon' and defaults daemon to DAEMON and port to DAEMON-PORT.
     4. (send-code #:name [name NAME] #:server [server SERVER] #:port [port SERVER-PORT] code)
Sends the quoted s-expressions 'code' to server 'server' on port 'port' as name 'name'. Defaults to sending to server SERVER on port SERVER-PORT with name NAME.
     5. (send-message #:name [name NAME] #:server [server SERVER] #:port [port SERVER-PORT] message)
Sends the string 'message' to server 'server' on port 'port' as name 'name'. Defaults to sending to server SERVER or port SERVER-PORT with name NAME.
     6. (request-message #:number index #:from name #:daemon [daemon DAEMON] #:port [port DAEMON-PORT])
Requests the message indexed 'index' in the database for user 'name' from daemon 'daemon' on port 'port'. 'daemon' and 'port' default to DAEMON and DAEMON-PORT.
     7. (request-code #:number index #:from name #:daemon [daemon DAEMON] #:port [port DAEMON-PORT])
Requests the code indexed 'index' in the database for user 'name' from daemon 'daemon' on port 'port'. 'daemon' and 'port' default to DAEMON and DAEMON-PORT.
     8. (display-message #:number index #:from name #:daemon [daemon DAEMON] #:port [port DAEMON-PORT] #:format-string [format-string FORMAT-STRING])
Displays prettily the message indexed 'index' in the database for user 'name' from daemon 'daemon' on port 'port' using the format string 'format-string'. 'daemon' and 'port' default to DAEMON and DAEMON-PORT, 'format-string' to FORMAT-STRING.
     9. (display-code #:number index #:from name #:daemon [daemon DAEMON] #:port [port DAEMON-PORT] #:format-string [format-string FORMAT-STRING])
Displays prettily the code indexed 'index' in the database for user 'name' from daemon 'daemon' on port 'port' using the format string 'format-string'. 'daemon' and 'port' default to DAEMON and DAEMON-PORT, 'format-string' to FORMAT-STRING.
     10. (evaluate-code #:number index #:from name #:daemon [daemon DAEMON] #:port [port DAEMON-PORT])
Evaluates the code indexed 'index' in the database for user 'name' from daemon 'daemon' on port 'port'. 'daemon' and 'port' default to DAEMON and DAEMON-PORT.
   iv. Datastore
    a. Exported
     1. list-datastore
Currently non-working list datastore, following standard format for datastores, returning a list of a put function and a get function.
     2. hash-datastore
Currently working hashtable datastore, following standard format for datastores, returning a list of a put function and a get function.
     3. DATASTORE
Created automatically from the configuration-option DATASTORE-TYPE, this is set to whichever datastore is configured to be used. When DATASTORE-TYPE is invalid or empty, defaults to hash-datastore.
   v. Utilities
    a. Exported
     1. (verify-data data)
Ensures that the data 'data' is in proper format (hopefully, preventing any functions from choking on that data. Returns #t when data passes, #f otherwise.
     2. (format-prettily message #:format-string [format-string FORMAT-STRING])
Prints message 'message' using format string 'format-string' (or default FORMAT-STRING). 'message' is in the standard (name type message) format and format-string is a string.
     3. (ignoring-errors code)
Executes 'code' ignoring all errors it might raise. Currently unused, but possibly useful.
     4. (print-all-source)
Returns all the source code of code-immersion as a (huge) string.
     5. (define-listener-and-verifier port close? body)
Macro (hacked-together and very nasty) that's used for both the daemon and the server. Read the code to find out more about this; it's really nasty but the code's probably more readable than any explanation that could be given here.
    b. Internal
     1. (string-from-text-file text-file-port)
Creates a string from a text file given the proper file port. Used by (print-all-source).
